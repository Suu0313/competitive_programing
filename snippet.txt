{
  "comment support":{
    "scope": "cpp",
    "prefix": "//",
    "body": [
      "/*",
      "$0",
      "//*/"
    ],
    "description": "long comment"
  },
  "using namespace std":{
    "prefix": "std",
    "scope": "cpp",
    "body": [
      "using namespace std;"
    ],
    "description": "using namespace std"
  },
  "type template":{
    "prefix": "type",
    "scope": "cpp",
    "body": "template<typename T>",
    "description": "type template"
  },
  "search support":{
    "scope": "cpp",
    "prefix": "ifin",
    "body": [
      "if(${x}<0||${H}<=${x}||${y}<0||${W}<=${y}) ${continue}"
    ],
    "description": "search on grid"
  },
  "setprecision":{
    "scope": "cpp",
    "prefix": "setp",
    "body": [
      "cout << fixed << setprecision(12);",
      "$0"
    ],
    "description": "fixed setprecision"
  },
  "binary_search":{
    "scope": "cpp",
    "prefix": "binary",
    "body": [
      "auto isok = [&](${type} ${x}){",
      "  ${0}",
      "};",
      "",
      "${type} ok = ${l}, ng = ${r};",
      "while(abs(ok-ng) > 1){",
      "  ${type} wj = (ok + ng)/2;",
      "  if(isok(wj)) ok = wj;",
      "  else ng = wj;",
      "}"
    ],
    "description":"binary search temp"
  },
  "Segment Tree": {
    "scope": "cpp",
    "prefix": "seg",
    "body": [
      "SegmentTree ${seg} = get_segtree<${type}>(",
      "  ${N},",
      "  ${e},",
      "  [](${type} ${a}, ${type} ${b}) { return ${fuga}; }",
      ");"
    ],
    "description": "Segment Tree Constructor"
  },
  "Lazy Segment Tree":{
    "scope": "cpp",
    "prefix": "lazy",
    "body": [
      "LazySegTree ${seg} = get_lazysegtree<${M},${OM}>(",
      "  ${N},",
      "  [](${M} ${a}, ${M} ${b}) { return ${hoge}; },",
      "  [](${M} ${c}, ${OM} ${d}, int ${e}) { return ${fuga}; },",
      "  [](${OM} ${f}, ${OM} ${g}) { return ${fugafuga}; },",
      "  ${me},",
      "  ${ome}",
      ");"
    ],
    "description": "Lazy Segment Tree Constructor"
  },
  "find roop":{
    "scope": "cpp",
    "prefix": "roop",
    "body": [
      "int ${d} = 0, ${t} = 0;",
      "VI ${Log}, ${dist}(${N},-1);",
      "",
      "while(${dist}.at(${t})<0){",
      "  ${dist}.at(${t}) = ${d}++;",
      "  ${Log}.PB(${t});",
      "  ${t} = ${next};",
      "}",
      "",
      "int ${len} = ${d} - ${dist}.at(${t});",
      "",
      "if(${K} < ${d}){",
      "  ${hoge}",
      "}else{",
      "  ${fuga}",
      "}"
    ],
    "description": "find roop by simulation"
  },
  "header":{
    "scope": "cpp",
    "prefix": "header",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "",
      "int main() {",
      "  ${0}",
      "}"
    ],
    "description": "cpp template"
  },
  "QCfium":{
    "scope": "cpp",
    "prefix": "qcfium",
    "body": [
      "#pragma GCC target(\"avx2\")",
      "#pragma GCC optimize(\"O3\")",
      "#pragma GCC optimize(\"unroll-loops\")"
    ],
    "description": "more faster more danger"
  },
  "fast io":{
    "scope": "cpp",
    "prefix": "fastio",
    "body": "cin.tie(0); ios::sync_with_stdio(false);",
    "description": "fast io"
  },
  "priority_queue":{
    "scope": "cpp",
    "prefix": "priority",
    "body": [
      "priority_queue pq{${f}, vector<${T}>()};"
    ],
    "description": "priority_queue"
  },
  "limits":{
    "scope": "cpp",
    "prefix": "limit",
    "body": [
      "numeric_limits<${T}>::${max}();"
    ],
    "description": "numeric_limits"
  },
  "serch on adjacency matrix": {
    "scope": "cpp",
    "prefix": "adj",
    "body": [
      "REP(${i},4){",
      "  int ${x} = ${a} + dx[${i}], ${y} = ${b} + dy[${i}];",
      "}"
    ],
    "description": "serch on adjacency matrix"
  },
  "create high dimensional vector":{
    "scope": "cpp",
    "prefix": "vv",
    "body": [
      "auto ${dp} = make_v(${0});"
    ]
  },
  "random":{
    "scope": "cpp",
    "prefix": "rnd",
    "body": [
      "random_device seed;",
      "mt19937 rng(seed());",
      "uniform_int_distribution<> db(${l}, ${r})"
    ]
  },
  "solver":{
    "scope": "cpp",
    "prefix": "solver",
    "body": [
      "struct Solver{",
      "  Solver() {}",
      "",
      "  void solve();",
      "};"
    ]
  },
  "Mo's Algorithm":{
    "scope": "cpp",
    "prefix": "mo",
    "body": [
      "for(int i : MoSort(n, q, l, r)){",
      "  while(nr < r[i]){",
      "    // add nr",
      "    ++nr;",
      "  }",
      "",
      "  while(l[i] < nl){",
      "    --nl;",
      "    // add nl",
      "  }",
      "",
      "  while(r[i] < nr){",
      "    --nr;",
      "    // rm nr",
      "  }",
      "",
      "  while(nl < l[i]){",
      "    // rm nl",
      "    ++nl;",
      "  }",
      "}"
    ],
    "description": "Mo's Algorithm"
  },
  "range for":{
    "scope": "cpp",
    "prefix": "fore",
    "body": [
      "for(auto&&${x} : ${v}){",
      "  ${0}",
      "}"
    ],
    "description": "range based for"
  },
  "subset for":{
    "scope": "cpp",
    "prefix": "forin",
    "body": [
      "for(int ${T} = 0; ; ${T} = (${T}-${S})&${S}){",
      "  ${0}",
      "  ",
      "  if(${T} == ${S}) break;",
      "}"
    ],
    "description": "enumerate subset in ascending order"
  },
  "subset forr":{
    "scope": "cpp",
    "prefix": "forrin",
    "body": [
      "for(int ${T} = ${S}; ; ${T} = (${T}-1)&${S}){",
      "  ${0}",
      "  ",
      "  if(${T} == 0) break;",
      "}"
    ],
    "description": "enumerate subset in descending order"
  },
  "superset for":{
    "scope": "cpp",
    "prefix": "forex",
    "body": [
      "for(int ${T} = ${S}; ${S} < (1<<${n}); ${T} = (${T}+1)|${S}){",
      "  ${0}",
      "}"
    ],
    "description": "enumerate subset (contained in 2^n)"
  },
  "nCk": {
    "scope": "cpp",
    "prefix": "forcom",
    "body": [
      "for(int ${s} = (1<<${k})-1; ${s} < (1<<${n}); ){",
      "  ${0}",
      "  ",
      "  int ${t} = ${s} | (${s}-1);",
      "  ${s} = (${t}+1) | (((~ ${t} & - ~ ${t}) - 1) >> (__builtin_ctz(${s}) + 1));",
      "}"
    ],
    "description": "enumerate subset popcnt==k in 2^n"
  },
}
